MemoryOrder	atomics.html#MemoryOrder	atomics: MemoryOrder	
Atomic	atomics.html#Atomic	atomics: Atomic	
AtomicFlag	atomics.html#AtomicFlag	atomics: AtomicFlag	
load	atomics.html#load,Atomic[T],MemoryOrder	atomics: load[T](location: var Atomic[T]; order: MemoryOrder = moSequentiallyConsistent): T	
store	atomics.html#store,Atomic[T],T,MemoryOrder	atomics: store[T](location: var Atomic[T]; desired: T;\n         order: MemoryOrder = moSequentiallyConsistent)	
exchange	atomics.html#exchange,Atomic[T],T,MemoryOrder	atomics: exchange[T](location: var Atomic[T]; desired: T;\n            order: MemoryOrder = moSequentiallyConsistent): T	
compareExchange	atomics.html#compareExchange,Atomic[T],T,T,MemoryOrder	atomics: compareExchange[T](location: var Atomic[T]; expected: var T; desired: T;\n                   order: MemoryOrder = moSequentiallyConsistent): bool	
compareExchange	atomics.html#compareExchange,Atomic[T],T,T,MemoryOrder,MemoryOrder	atomics: compareExchange[T](location: var Atomic[T]; expected: var T; desired: T;\n                   success, failure: MemoryOrder): bool	
compareExchangeWeak	atomics.html#compareExchangeWeak,Atomic[T],T,T,MemoryOrder	atomics: compareExchangeWeak[T](location: var Atomic[T]; expected: var T; desired: T;\n                       order: MemoryOrder = moSequentiallyConsistent): bool	
compareExchangeWeak	atomics.html#compareExchangeWeak,Atomic[T],T,T,MemoryOrder,MemoryOrder	atomics: compareExchangeWeak[T](location: var Atomic[T]; expected: var T; desired: T;\n                       success, failure: MemoryOrder): bool	
fetchAdd	atomics.html#fetchAdd,Atomic[T: SomeInteger],T,MemoryOrder	atomics: fetchAdd[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T	
fetchSub	atomics.html#fetchSub,Atomic[T: SomeInteger],T,MemoryOrder	atomics: fetchSub[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T	
fetchAnd	atomics.html#fetchAnd,Atomic[T: SomeInteger],T,MemoryOrder	atomics: fetchAnd[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T	
fetchOr	atomics.html#fetchOr,Atomic[T: SomeInteger],T,MemoryOrder	atomics: fetchOr[T: SomeInteger](location: var Atomic[T]; value: T;\n                        order: MemoryOrder = moSequentiallyConsistent): T	
fetchXor	atomics.html#fetchXor,Atomic[T: SomeInteger],T,MemoryOrder	atomics: fetchXor[T: SomeInteger](location: var Atomic[T]; value: T;\n                         order: MemoryOrder = moSequentiallyConsistent): T	
testAndSet	atomics.html#testAndSet,AtomicFlag,MemoryOrder	atomics: testAndSet(location: var AtomicFlag;\n           order: MemoryOrder = moSequentiallyConsistent): bool	
clear	atomics.html#clear,AtomicFlag,MemoryOrder	atomics: clear(location: var AtomicFlag; order: MemoryOrder = moSequentiallyConsistent)	
fence	atomics.html#fence,MemoryOrder	atomics: fence(order: MemoryOrder)	
signalFence	atomics.html#signalFence,MemoryOrder	atomics: signalFence(order: MemoryOrder)	
atomicInc	atomics.html#atomicInc,Atomic[T: SomeInteger],T	atomics: atomicInc[T: SomeInteger](location: var Atomic[T]; value: T = 1)	
atomicDec	atomics.html#atomicDec,Atomic[T: SomeInteger],T	atomics: atomicDec[T: SomeInteger](location: var Atomic[T]; value: T = 1)	
`+=`	atomics.html#+=,Atomic[T: SomeInteger],T	atomics: `+=`[T: SomeInteger](location: var Atomic[T]; value: T)	
`-=`	atomics.html#-=,Atomic[T: SomeInteger],T	atomics: `-=`[T: SomeInteger](location: var Atomic[T]; value: T)	
